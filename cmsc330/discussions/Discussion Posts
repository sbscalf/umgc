[SCALF] Week 1: Creating Parse Trees

## PROMPT

To verify that a string of characters belongs to a language defined by a grammar, we must create a parse tree that shows that the string can be generated by the grammar.

Consider the following grammar:

<list> -> <item> , <list> | <item> 
<item> -> <left> <item> <right> | <left> <right>
<left> -> A| B | C 
<right> -> x | y | z

Choose a string that is in this language and create a parse tree that demonstrates that your claim is true. Identify another string that contains some of these terminals symbols but is not in the language.

Obs:

1. Avoid repeating what was already posted - your strings must be different than the already posted strings.

2. Your strings must have a length of at least 5 symbols.


## POST

My valid string is Ax,BAyz. My invalid string is CABBy.

Ax,BAyz Parse Tree:
>insert scanned image<

CABBy Parse Tree:
>insert scanned image<


================================================================================

[SCALF] Week 2: Grammar Restrictions for Recursive Descent Parsers

## PROMPT

There are two restrictions on the type of grammars that can be used with a recursive descent parser. The first is that the grammar cannot have any left recursive productions. Give an example of a left recursive production and explain why such productions would be a problem.

The second restriction is that the grammar must not require more than one token look ahead. Give an example of a production that does not have this property. Explain why this restriction is necessary for recursive descent parsing.


## POST

An example of a left recursive production is
SUM ::= SUM + PRIMARY | PRIMARY

The restriction of not having left recursive productions is that the first statement in the parsing method would be an unconditional recursive call on the same method.  In other words, since the current token is "SUM" this will automatically be seen as a valid case for the first part of the production and make a call to the "parseSUM" method ad infinitum.  Due to the limitations of computer systems, this loop will eventually cause a stack overflow error, but if it were not for this physical limitation, the loop would continue forever.

The second restriction had me a bit confused at first.  From what I understand, this restriction is required in order to determine which right-hand side of the production to use.  To go along with this is a requirement that all right-hand sides of a production begin with a unique token. If not, the parser would have to look ahead by more than one token as it would need to look at the second or later token in a production to find the unique right-hand side that matches the token pattern.  This would be, potentially much, harder to program than an LL(1) grammar, or a grammar that only requires one token lookahead.

To be honest, though, I'm kind of grasping at straws for the second restriction.  I've put what I got, but I could use some help with understanding the requirement.  Is it a requirement of all recursive descent parsers or LL(1) parsers?  I did not have much luck consulting the oracle (i.e. searching Google), and the second part of the Parsers video simply stated: "If the grammar contains a production with multiple right-hand sides in which two or more of those right-hand sides begin with the same token, we will be unable to use the technique described in part one for parsing such productions."  The example production that was given in the referenced part one was statement -> if_statement | while_statement | for_statement.  Would this mean a production like "<list> ::= <item> , <list> | <item>" could not be used with recursive descent?


================================================================================

[SCALF] Week 3: Examining the Scope Rules of Java

## PROMPT

The scope rules of modern programming languages are rooted in rules developed by the earliest block structured languages like Algol. Adding object orientation to languages adds one more layer of complexity to this issue.

Let's consider Java, a language with which everyone should be familiar, and explore its scope rules. One aspect of the scope rules of any language is when data or methods can have the same name. Give examples in Java to illustrate a case where declaring two local variables with the same name in same method is permitted and one where it is prohibited. Are the rules governing redeclaration of local names the same as those governing redeclaring local names that rename class-level names?

One consequence of scope rules in most languages is that forward references (referring to names before they are declared) are prohibited. Are such forward references always prohibited within a single Java class? Are forward references of local names always prohibited within a single method? If not, provide an example that demonstrates your claim.


##POST

The only way it is possible to declare two variables with the same name in the same method is if both variables are in separate blocks, whether that be in a loop or simply surrounded by curly brackets.

void method() {
    {                                     // Sub-Block 1
        int var = 99;
        System.out.println(var)
    }
    for (int i = 0; i < 10; i++) {        // Sub-Block 2
    	int var = i;                      // Redeclares "var" with each iteration and is
    	System.out.println(var)           // still valid as each iteration is a separate block
    }
}

Same name variable declarations are prohibited within the same block. If 'var' was ever declared directly under method() (i.e. not within another pair of curly brackets), then all following variable declarations (in the method) using the same name would be invalid.

void method() {
    int var = 99;    // var declared at method level
    {
        int var = 2; // Invalid, because "var" was already declared within the block.
    }
}

These rules are different when it involves class-level names. Class-level variables, or fields, can be hidden by local variables.  The local variable is not a redeclaration of the same variable, but rather a different scope. In Java, this is known as shadowing. In these instances, the class-level variable can be accessed by using the full name of the variable.  I have used shadowing extensively in contructors.  With constructors, instances have a special name of "this," so the full name of the variable is "this.var," replacing "var" with the name of the variable.  Static class variables can be referneced using the "ClassName.field." The only time I did something that used the static class variable was when I made a custom tree and used the same name for the root of the tree and subtree.  When I did that, the subtree's root was simply "root," but the class's root was "Tree.Root."  I don't remember why I had implemented that; perhaps it was to check if the subtree root and class's root were the same.

Within a single Java class, forward referencing is not strictly prohibited.  For example, I could declare "boolean isEnabled = getEnabled()" before declaring the method "boolean getEnabled()" and the program would compile and run just fine.  Another time forward referencing is allowed is when declaring a non-static variable to the value of a static variable:

int x = y;
static int y = 1;

This is valid because static variables are assigned values at compilation time, whereas the non-static variable is assigned a value at run time.  For this same reason, static variables cannot forward reference other variables (to include other static variables), nor can non-static variables forward reference other non-static variables.

"Java in a Nutshell" explains this well stating: "A method may refer to a variable or another method of its class, regardless of where in the current class the variable or method is defined. Similarly, it may refer to any class, regardless of where in the current file (or outside of the file) that class is defined. The only place that forward references are not allowed is in variable initialization. A variable initializer (for local variables, class variables, or instance variables) may not refer to other variables that have not yet been declared and initialized." (D. Flanagan, “2.14 Miscellaneous Differences,” in Java in a nutshell: a desktop quick reference, 2nd ed., Cambridge: O'Reilly & Associates, 1997.)


================================================================================

[SCALF] Week 4:

## PROMPT

Although Java has the rule that the left operand of every binary operator is evaluated before the right operand, most languages give the compiler the freedom to choose which operand is evaluated first. When expressions have side effects, the value of the expression can be different depending upon which order is used. Give an example in C++ of an expression whose value depends upon the evaluation order. Show the orders that produce different values and the values they produce. Explain what side effect is the expression contains.

##POST

My example in C++ of an expression whose value depends upon the evaluation order is fairly simple.

	#include <iostream>
	using namespace std;

	int main()
	{
	  int a = 2;
	  int b = 3;
	  int j = (a--) + (b*a);

	  a = 2;
	  b = 3;
	  int k = (b*a) + (a--);

	  cout << j << "  " << k << endl;

	  return 0;
	}

	Output:
	5  8

In the first expression, the value of 'a' is evaluated to "2", then changed to "1".  When the right side is then evaluated, the result is "3 *1).  This gives us the result of 2 + 3 = 5.

In the second expression, the left is evaluated to "6".  When the right side is evaluated, it is resolved to "2," then the value of a is reduced.  This gives us the result of 6 + 2 = 8.

I tested to see if the results would change with each execution as well as if it would change after recompilation: they didn't.

<SCREENSHOT OF OUTPUT>


================================================================================

[SCALF] Week 5: Which Language Has The Best Approach to Parameter Passing?

## PROMPT

One characteristic of programming languages that varies widely from language to language is how parameters are passed. Among ALGOL, Pascal, Ada, C, C++, Java, and C#, no two languages pass parameters in exactly the same way. Among these languages, choose the one that you believe has adopted the best approach to parameter passing. Defend your decision by outlining the advantages of the approach of the language that you chose and the disadvantages of the approaches taken by other languages.

##POST

I believe that C++ has adopted the best approach to parameter passing.  While it only uses call by value, strictly speaking, by using pointers and references it is also able to effectively call by reference as well.  I believe this makes it a very flexible language that can be used to create very efficient code.

While it is possible to achieve similar results in Ada by being able to choose the mode, it is not simultaneous like C++.  C++ is in a constant mode of "In," to meet the call by value, but, as stated earlier, it is able to retain changes to the arguments after the subprogram completes by using pointers/references. In Ada, if the In-Out or Out mode is chosen, the programmer loses the ability to pass constants and expressions as parameters.

Java is also able to achieve something similar to C++ in that changes to the fields of any object passed as a parameter are retained, this is not true for primitive types.  In C++, a reference to a primitive type (e.g. int, char, etc.) passed as a parameter can be used to retain such changes.

The only time I've used named association has been with PowerShell scripts.  PowerShell uses the .NET Framework which is based on C#. While named association is great for fully interpreted languages like PowerShell, I believe it is superfluous in compiled languages.  Since starting my major, I've been required to create my own Java classes for data structures, exceptions, and more.  As a result, I have become very familiar with my own programs.  I know exactly what parameters are needed.  Besides, the need for named association is somewhat eliminated by overloading methods.  Sure overloading methods takes more storage, but resolving named parameters makes compilation more complex.

C# also allows default values, just like Ada.  Still, default values can lead to ambiguity when overloading methods.  Even though PowerShell attempts to overcome this by having Parameter Sets, many times I have received an error stating: "Parameter set cannot be resolved using the specified named parameters".  By not allowing default values, C++ eliminates some of the ambiguity that may unintentionally arise.

I have not really used C++, because most of my courses have required the use of Java.  After preparing for this, I have decided to become more familiar with the language.  On the other hand, I feel that my knowledge of different aspects of <b>all</b> languages (e.g. data structures) has prepared me to learn any language: the principles are largely similar despite the implementation (e.g. syntax) being different. 


================================================================================

[SCALF] Week 6: Separating the Specification and Implementation

## PROMPT

One important difference between languages that provide syntax to encapsulate the definition of user defined data types is whether the syntax requires the specification details to be separated from the implementation details. Ada requires such a separation. In Ada, the specification information must be placed in the package specification and the implementation details in the package body. Where must the representation details be placed?

Compare Ada with both C++ and Java in this regard. Take and defend a position as to whether requiring separation of the specification and representation information for a data type is a good language design decision.


##POST

In Ada, the representation details must be placed in the package body along with the implementation.

Both C++ and Java have the means to accomplish this same thing.  While Ada has package specification, C++ has headers and Java has interfaces and abstract classes.  C++ prefers the use of header files, but it is not required. Java has no such requirement.

I believe the separation of the specification and representation information is a really good standard to have, but I do not think it should be enforced.  In the case of larger programs, especially those built by a team, I can definitely see the benefit.  By having the specification separate, team members working on other portions of code that must also reference the same methods, for example, will all be using the same names and sets of parameters.  The only person that needs to know the implementation/representation is the one writing it.  For example, when I use a math function for exponents, like int exp(int base, int power), I don't need to know exactly how it's performing the calculation, just that it returns the desired value.

On a small project written by a lone developer, however, it seems a little superfluous and perhaps overbearing.  If I'm writing a small-to-medium-sized SOHO application, I would most likely be writing it on my own.  Even in the case of reusing lots of subprograms, I would most likely have a utility class or library that declares and defines those subprograms.  I have still used interfaces and abstract classes in my code to allow for expansion, but definitely not for every single source file.

Overall, I think I like Java's model the most.  With Java's model, standards for the use of interfaces and abstract classes can be enforced and made a requirement for the team or company.  This also allows developers to create only as many files as necessary.  I know that storage space isn't as much of an issue as it was in the past, but I don't think that should be an excuse.  I think it would have been ridiculous if every single-file Java application I wrote required me to have a second file that simply declared each of the variables and methods.  It's extra work that provides no added benefit, in this case.  I will give C++ a break, as they do not require it and only prefer it, but I like the idea of a leaving it to the community to define best practices and to teams/companies to define internal requirements.


================================================================================

[SCALF] Week 7: Multiple Inheritance

## PROMPT

Among object-oriented languages, one feature that varies considerably is whether the language allows multiple inheritance. C++ does but Ada does not. Java takes a middle ground approach of allowing multiple inheritance of interfaces but not classes. Using a C++ example, illustrate some of the complexities that multiple inheritance introduces. How does C++ deal with them? Why does Java's middle ground approach offer some of the benefits of multiple inheritance while avoids its problems.


##POST

I've learned that, with C++, a class could have two parents that have a shared parent (i.e. the two parents are "siblings"). When this happens, a question arrises as to whether to include the "grandparent" twice, or just once. If including just once, which parent gets to include it?

When I started working on Project 2, I noticed that Eclipse included three lines in new header files:
	#ifndef NAMEOFHEADER_H_
	#define NAMEOFHEADER_H_

	#endif /* NAMEOFHEADER_H_ */

Every thing for the header goes between those lines.  This is one method a programmer can use to prevent issues, because it prevents the header file from being redefined.  I believe it is called an "include guard."  With this method, the parent class would only ever be included once, and it would usually be with the first source in the compilation chain that included the header.  This includes classes and subclasses that do not explicitly import the parent header file.

Java, on the other hand, does not "include" the entire code for an interface in each class that implements it.  In Java, an interface simply declares what functions/methods must be defined in implementations and requires all variables to be final and static.  Since Java does not require methods to be declared before they are defined, and allows methods to be declared/defined anywhere in the code, the interface code does not necessarily need to be included, especially if it only contains abstract methods.  In this case, it serves as more of a type identifier and guarantee that the class implementing it has the methods.

================================================================================

[SCALF] Week 8: Is Language Support for Concurrency Essential?

## PROMPT

Many programming languages, especially older ones, provide no language support for concurrency. C and C++ are examples of such languages. Is it essential that a language include syntax for concurrency to be able to write concurrent programs in that language? If not, how is it accomplished? What are the advantages and disadvantages of including support for concurrency in a language?


##POST


